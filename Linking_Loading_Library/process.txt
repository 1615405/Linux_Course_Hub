1.  进程只能使用那些操作系统分配给进程的地址, 如果访问未经允许的空间, 那么操作系统就会捕获到这些访问, 将进程的这种访问当作非法操作, 强制结束进程.


2.  从硬件层面上来讲, 原先的32位地址线只能访问最多4GB的物理内存. 但是自从扩展至36位地址线之后, Intel 修改了页映射的方式, 使得新的映射方式可以访问
    到更多的物理内存. Intel把这个地址扩展方式叫做PAE.


3.  创建一个进程, 然后装载相应的可执行文件并且执行.
    - 创建一个独立的虚拟地址空间.
    - 读取可执行文件头, 并且建立虚拟空间与可执行文件的映射关系.
    - 将CPU的指令寄存器设置成可执行文件的入口地址, 启动运行.


4.  操作系统通过给进程空间划分出一个个VMA来管理进程的虚拟空间; 基本原则是将相同权限属性的, 有相同映像文件的映射成一个VMA; 一个进程基本上可以分为
    如下几种VMA区域:
    - 代码VMA, 权限只读, 可执行, 有映像文件
    - 数据VMA, 权限可读写, 可执行, 有映像文件
    - 堆VMA, 权限可读写, 可执行, 无映像文件, 匿名, 可向上扩展
    - 栈VMA, 权限可读写, 不可执行, 无映像文件, 匿名, 可向下扩展
    - 查看内存映射:  ./section.elf &    cat /proc/59320/maps


5.  在Linux系统的bash下输入一个命令执行某个ELF程序时, Linux装载这个ELF文件并且执行的过程.
    - 首先在用户层面, bash进程会调用fork()系统调用创建一个新的进程, 然后新的进程调用execve()系统调用执行指定的ELF文件, 原先的bash进程继续返回
      等待刚才启动的新进程结束, 然后继续等待用户输入命令.
    - 原型:  int execve(const char* filename, char* const argv[], char* const envp[]);
    - 三个参数分别是被执行的程序文件名, 执行参数和环境变量. Glibc 对execvp()系列调用进行了包装, 提供了execl(), execlp(), execle(), execv()
      和execvp()等5个不同形式的exec系列API, 它们只是在调用的参数形式上有所区别, 但最终都会调用到execve()这个系统调用函数.
