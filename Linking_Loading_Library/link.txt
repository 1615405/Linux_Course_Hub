1.  在链接中, 目标文件之间相互拼合实际上是目标文件之间对地址的引用, 即对函数和变量的地址的引用. 在链接中,
    我们将函数和变量统称为符号, 函数名或变量名就是符号名.


2.  链接过程中很关键的一部分就是符号的管理, 每一个目标文件都会有一个相应的符号表, 这个表里面记录了目标文件中
    所用到的所有符号. 每个定义的符号有一个对应的值, 叫做符号值. 对于变量和函数来说, 符号值就是它们的地址.


3.  ELF 符号表结构
    /* Symbol table entry.  */
    typedef struct {
      Elf32_Word    st_name;                /* Symbol name (string tbl index) */
      Elf32_Addr    st_value;               /* Symbol value */
      Elf32_Word    st_size;                /* Symbol size */
      unsigned char st_info;                /* Symbol type and binding */
      unsigned char st_other;               /* Symbol visibility */
      Elf32_Section st_shndx;               /* Section index */
    } Elf32_Sym;
    nm SimpleSection.o   // 查看SimpleSection.o的符号结果


4.  特殊符号
    - __executable_start: 该符号为程序的起始地址, 不是入口地址, 是程序的最开始的地址.
    - __etext__: 该符号为代码段结束地址, 即代码段最末尾的地址.
    - _edata: 该符号为数据段结束地址, 即数据段最末尾的地址.
    - _end: 该符号为程序结束地址. 以上地址都为程序被装载时的虚拟地址.


5.  编译器默认函数和初始化的全局变量为强符号, 未初始化的全局变量为弱符号.
    - 规则1: 不允许强符号被多次定义(即不同的目标文件中不能有同名的强符号); 如果有多个强符号定义, 则链接器报符号重复定义错误.
    - 规则2: 如果一个符号在某个目标文件中是强符号, 在其他文件中是弱符号, 那么选择强符号.
    - 规则3: 如果一个符号在所有目标文件中都是弱符号, 那么选择其中占用空间最大的一个.

        extern int ext;  // 外部引用
    
        int weak;  // 弱符号
        int strong = 1  // 强符号
        
        __attribute__((weak))  weak2 = 2  // 弱符号
        
        int main()  // 强符号
        {
            return 0;
        }


6.  对外部目标文件的符号引用在目标文件被最终链接成可执行文件时, 它们须要被正确决议, 如果没有找到该符号的定义, 链接器就会报符号未定义错误(强引用).
    在处理弱引用时, 如果该符号有定义, 则链接器将该符号的引用决议; 如果该符号未被定义, 则链接器对于该引用不报错. 对于未定义的弱引用, 链接器不认为
    它是一个错误. 一般对于未定义的弱引用, 链接器默认其为0, 或者是一个特殊的值, 以便于程序代码能够识别.
        __attribute__ ((weakref)) void foo();
    
        int main()
        {
            if (foo())  foo();  // 避免非法地址访问
        }


7.  链接过程
    1) 空间与地址分配: 扫描所有的输入目标文件, 获得它们的各个段的长度, 属性和位置, 并且将输入目标文件中的符号表中所有的符号定义和符号
           引用收集起来, 统一放到一个全局符号表. 这一步中, 链接器将能够获得所有输入目标文件的段长度, 并且将它们合并, 计算输出文件中
           各个段合并后的长度与位置, 并建立映射关系.
    2) 符号解析与重定位: 使用上面第一步中收集到的所有信息, 读取输入文件中段的数据, 重定位信息, 并且进行符号解析与重定位, 调整代码中的地址等.
           事实上第二步是链接过程的核心, 特别是重定位过程.
        -> odjdump -r a.o 查看目标文件的重定位表


8. 符号解析: 重定位过程也伴随着符号的解析过程, 每个目标文件都可能定义一些符号, 也可能引用到定义在其他目标文件的符号. 重定位的过程中, 每个重定位
       的入口都是对一个符号的引用, 那么当链接器需要对某个符号的引用进行重定位时, 它就要确定这个符号的目标地址. 这时候链接器就会去查找由所有输入
       目标文件的符号表组成的全局符号表, 找到相应的符号后进行重定位.
        -> readelf -s a.o  查看 a.o 的符号表


9. GCC的"fno-common"允许我们把所有未初始化的全局变量不以COMMON块的形式处理, 或者使用 __attribute__ 扩展:
      int global __attribute__ ((nocommon))
   一旦一个未初始化的全局变量不是以 COMMON 块的形式存在, 那么它就相当于一个强符号, 如果其他目标文件中还有同一个变量的强符号定义, 链接就会
   发生符号重定义错误.
