1.  在链接中, 目标文件之间相互拼合实际上是目标文件之间对地址的引用, 即对函数和变量的地址的引用. 在链接中,
    我们将函数和变量统称为符号, 函数名或变量名就是符号名.

2.  链接过程中很关键的一部分就是符号的管理, 每一个目标文件都会有一个相应的符号表, 这个表里面记录了目标文件中
    所用到的所有符号. 每个定义的符号有一个对应的值, 叫做符号值. 对于变量和函数来说, 符号值就是它们的地址.

3.  ELF 符号表结构
    /* Symbol table entry.  */
    typedef struct {
      Elf32_Word    st_name;                /* Symbol name (string tbl index) */
      Elf32_Addr    st_value;               /* Symbol value */
      Elf32_Word    st_size;                /* Symbol size */
      unsigned char st_info;                /* Symbol type and binding */
      unsigned char st_other;               /* Symbol visibility */
      Elf32_Section st_shndx;               /* Section index */
    } Elf32_Sym;
    nm SimpleSection.o   // 查看SimpleSection.o的符号结果

4.  特殊符号
    - __executable_start: 该符号为程序的起始地址, 不是入口地址, 是程序的最开始的地址.
    - __etext__: 该符号为代码段结束地址, 即代码段最末尾的地址.
    - _edata: 该符号为数据段结束地址, 即数据段最末尾的地址.
    - _end: 该符号为程序结束地址. 以上地址都为程序被装载时的虚拟地址.

5.  编译器默认函数和初始化的全局变量为强符号, 未初始化的全局变量为弱符号.
    - 规则1: 不允许强符号被多次定义(即不同的目标文件中不能有同名的强符号); 如果有多个强符号定义, 则链接器报符号重复定义错误.
    - 规则2: 如果一个符号在某个目标文件中是强符号, 在其他文件中是弱符号, 那么选择强符号.
    - 规则3: 如果一个符号在所有目标文件中都是弱符号, 那么选择其中占用空间最大的一个.

        extern int ext;  // 外部引用
    
        int weak;  // 弱符号
        int strong = 1  // 强符号
        
        __attribute__((weak))  weak2 = 2  // 弱符号
        
        int main()  // 强符号
        {
            return 0;
        }

6.  对外部目标文件的符号引用在目标文件被最终链接成可执行文件时, 它们须要被正确决议, 如果没有找到该符号的定义, 链接器就会报符号未定义错误(强引用).
    在处理弱引用时, 如果该符号有定义, 则链接器将该符号的引用决议; 如果该符号未被定义, 则链接器对于该引用不报错. 对于未定义的弱引用, 链接器不认为
    它是一个错误. 一般对于未定义的弱引用, 链接器默认其为0, 或者是一个特殊的值, 以便于程序代码能够识别.
        __attribute__ ((weakref)) void foo();
    
        int main()
        {
            if (foo())  foo();  // 避免非法地址访问
        }
