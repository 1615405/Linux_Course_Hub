1. 预编译过程主要处理那些源代码文件中的以#开始的预编译指令. 比如#include，#define等, 主要处理规则如下:
    - 将所有的#define删除, 并且展开所有的宏定义
    - 处理所有条件预编译指令, 比如#if，#ifdef，#elif，#else，#endif
    - 处理#include预编译指令, 将被包含的文件插入到该预编译指令的位置. 注意, 这个过程是递归进行的, 也就是说被包含的文件可能还包含其他文件
    - 删除所有的注释//和/* */
    - 添加行号和文件名标识, 以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号
    - 保留所有的#pragma编译器指令, 因为编译器须要使用它们


2. 编译过程就是把预处理完的文件进行一系列词法分析, 语法分析, 语义分析及优化后生产相应的汇编代码文件
    - 现在版本的GCC把预编译和编译两个步骤合并成一个步骤, 使用一个叫做cc1的程序来完成这两个步骤
    - 对于C语言的代码来说, 这个预编译和编译的程序是cc1; 对于c++来说, 有对应的程序叫做cc1plus; objective-C是cc1obj; 
      fortan是f771; Java是jc1. 所以实际上gcc这个命令只是这些后台程序的包装, 它会根据不同的参数要求去调用预编译程序cc1, 汇编器as, 链接器ld


3. 词法分析
    - 首先源代码程序被输入到扫描器, 扫描器的任务很简单, 它只是简单地进行词法分析, 运用一种类似于有限状态机的算法可以很轻松地将源代码的字符序列
      分割成一系列的记号。
    - 词法分析产生的记号一般可以分为如下几类: 关键字, 标识符, 字面量和特殊符号. 在识别记号的同时, 扫描器也完成了其他工作.比如将标识符放到符号表,
      将数字, 字符串常量存放到文字表等, 以备后面的步骤使用.
    - 有一个叫做lex的程序可以实现词法扫描, 它会按照用户之前描述好的词法规则将输入的字符串分割成一个个记号.


4. 语法分析
    - 接下来语法分析器将对由扫描器产生的记号进行语法分析，从而产生语法树。整个分析过程采用上下文无关语法的分析手段。
    - 正如前面词法分析有lex一样，语法分析也有一个现成的工具叫做yacc。它也像lex一样，可以根据用户给定的语法规则对输入的记号序列进行解析，
      从而构建出一棵语法树。


5. 语义分析
    - 接下来进行的是语义分析，由语义分析器来完成。语法分析仅仅是完成了对表达式的语法层面的分析，但是它并不了解这个语句是否真正有意义。
      比如C语言里面两个指针做乘法运算是没有意义的，但是这个语句在语法上是合法的；
    - 编译器所能分析的语义是静态语义，所谓静态语义是指在编译期可以确定的语义，与之对应的动态语义就是只有在运行期才能确定的语义。
    - 静态语义通常包括声明和类型的匹配，类型的转换。比如当一个浮点型的表达式赋值给一个整数的表达式时，其中包含了一个浮点型到整型转换的过程，
      语义分析过程中需要完成这个步骤。比如将一个浮点型赋值给一个指针的时候，语义分析程序会发现这个类型不匹配，编译器将会报错。
      动态语义一般指在运行期出现的语义相关的问题，比如将0作为除数是一个运行期语义错误。


6. 中间语言生成
    - 现代的编译器有着很多层次的优化，往往在源代码级别会有一个优化过程。我们这里所描述的源码级优化器在不同编译器中可能会有不同的定义和
      一些其他的差异。
    - 源代码优化器往往将整个语法树转换成中间代码，它是语法树的顺序表示，其实已经非常接近目标代码了。但是它一般跟目标机器和运行时环境是无关的，
      比如它不包含数据的尺寸，变量地址和寄存器的名字等。
    - 中间代码有很多种类型，在不同的编译器中有着不同的形式，比较常见的有：三地址码和P-代码。


7. 目标代码生成与优化
    - 源代码级优化器产生中间代码标志着下面的过程都属于编译器后端。编译器后端主要包括代码生成器和目标代码优化器。
    - 代码生成器将中间代码转换成目标机器代码，这个过程十分依赖于目标机器，因为不同的机器有着不同的字长，寄存器，整数数据类型和浮点数数据类型等。
    - 最后目标代码优化器对上述的目标代码进行优化，比如选择合适的寻址方式，使用位移来代替乘法运算，删除多余的指令等。
    - 中间代码使得编译器可以被分为前端和后端. 编译器负责产生机器无关的中间代码, 编译器后端将中间代码转换成目标机器代码


8. 链接
    - 最常见的属于静态语言的C/C++模块之间通信有两种方式，一种是模块间的函数调用，另一种是模块间的变量访问。函数访问须知道目标函数的地址，
      变量访问也须知道目标变量的地址，所以这两种方式都可以归结为一种方式，那就是模块间符号的引用。
    - 模块间依靠符号来通信类似于拼图版，定义符号的模块多出一块区域，引用该符号的模块刚好少了那一块区域，两者一拼接刚好完美组合。
    - 链接过程主要包括了地址和空间分配，符号决议和重定位这些步骤。
    - 最常见的库是运行时库（Runtime Library），它是支持程序运行的基本函数的集合。库其实是一组目标文件的包，就是一些最常用的代码编译成目标文件
      后打包存放。
    - 地址修正的过程也被叫做重定位，每个要被修正的地方叫一个重定位入口。重定位所做的就是给程序中每个这样的绝对地址引用的位置打补丁，
      使它们指向正确的地址。


9. 编译命令
    - 预编译：gcc -E hello.c -o hello.i  或者  cpp hello.c > hello.i
    - 编译: gcc -S hello.i -o hello.s
    - 汇编: as helloc.s -o hello.o  或者  gcc -c hello.s -o hello.c
    - 查找: find /usr/lib -name crt1.o

ld -static \
  /usr/lib/x86_64-linux-gnu/crt1.o \
  /usr/lib/x86_64-linux-gnu/crti.o \
  /usr/lib/gcc/x86_64-linux-gnu/11/crtbeginT.o \
  hello.o \
  -L/usr/lib/gcc/x86_64-linux-gnu/11 \
  -L/usr/lib/x86_64-linux-gnu \
  -start-group \
  -lgcc \
  -lgcc_eh \
  -lc \
  -end-group \
  /usr/lib/gcc/x86_64-linux-gnu/11/crtend.o \
  /usr/lib/x86_64-linux-gnu/crtn.o


10. 静态库制作
    - gcc -c *.c -I ../include
    - ar rcs libcalc.a *.o
    - gcc main.c -o app -I ./include -lcalc -L ./lib


11. 动态库制作
    - gcc -c -fPIC *.c -I ../include/                    得到位置无关的代码
    - gcc -shared *.o -o libcalc.so                      得到动态库
    - gcc main.c -I include/ -L lib -lcalc -o main       链接动态库
    - ldd                                                检查动态库依赖关系
    - 当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统的动态载入器来获取该绝对路径。
      对于elf格式的可执行程序，是由ld-linux.so来完成的，它先后搜索elf文件的 DT_RPATH段 ——> 环境变量 LD_LIBRARY_PATH ——> 
      /etc/ld.so.cache文件列表
    - export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/root/autodl-tmp/calc/lib   临时环境变量
    - vi /etc/ld.so.conf  写入依赖库的路径  并 sudo ldconfig 


12. GCC常见编译选项
    -E: 预处理指定的源文件, 不进行编译
    -S: 编译指定的源文件, 但是不进行汇编
    -c: 编译, 汇编指定的源文件，但是不进行链接
    -o [file1] [file2] / [file2] -o [file1]: 将文件 file2 编译成可执行文件 file1
    -I directory: 指定 include 包含文件的搜索目录
    -g: 在编译的时候，生成调试信息，该程序可以被调试器调试
    -D: 在程序编译的时候，指定一个宏
    -w: 不生成任何警告信息
    -Wall: 生成所有警告信息
    -On: 编译器优化选项的4个级别
    -l: 在程序编译的时候，指定使用的库
    -L: 指定编译的时候，搜索的库的路径
    -fpic/-fPIC: 生成与位置无关的代码
    -shared: 生成共享目标文件，通常用在建立共享库时


13. 一个标准的线程由线程ID, 当前指令指针(PC), 寄存器集合和堆栈组成. 通常意义上, 一个进程由一个到多个线程组成, 各个线程之间共享程序的
    内存空间(包括代码段, 数据段, 堆等)及一些进程级的资源(如打开文件和信号).
    - 线程的访问权限
        1) 线程私有: 局部变量, 函数的参数, 线程局部存储(TLS数据)
        2) 线程共享: 全局变量, 堆上的数据, 函数里的静态变量, 程序代码, 打开文件


14. 线程安全
    - 竞争与原子操作    - 同步与锁   - 可重入与线程安全
    - volatile 关键字试图阻止编译器过度优化
        1): 阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回.
        2): 阻止编译器调整操作volatile变量的指令顺序.
