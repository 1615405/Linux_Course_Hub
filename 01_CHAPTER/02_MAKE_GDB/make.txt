1.  Makefile 规则
    - 一个 Makefile 文件中可以有一个或者多个规则
      目标 ...: 依赖 ...
          命令 (shell命令)
          ...
      - 目标：最终要生成的文件(伪目标除外)
      - 依赖: 生成目标所需要的文件或是目标
      - 命令: 通过执行命令对依赖操作生成目标
  - Makefile 中的其他规则一般都是为第一条规则服务的
  - 命令在执行之前，需要先检查规则中的依赖是否存在
  - 检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间



2.  变量
    - 自定义变量: 变量名=变量值  var=hello  $(var)
    - 预定义变量：
        - AR: 归档维护程序的名称，默认值是 ar
        - CC: C 编译器的名称，默认值为 cc
        - CXX: C++编译器的名称，默认值为 g++
        - $@: 目标的完整名称
        - $<: 第一个依赖文件的名称
        - $^: 所有的依赖文件



3.  GDB调试
    - gcc -g -Wall program.c -o program
    - 启动和退出:
        gdb: 可执行程序    quit: 退出
    - 给程序设置参数/获取设置参数
        set args 10 20
        show args
    - GDB使用帮助
        help
    - 查看文件代码
        list  -> 从默认位置显示    list 行号 -> 从指定的行显示
        list 函数名 -> 从指定的函数显示
    - 查看非当前文件代码
        list 文件名:行号     list 文件名:函数名
    - 设置断点
        - break 行号     - break 函数名   - break 文件名:行号    - break 文件名:函数
    - 查看断点
        info break
    - 删除断点
        delete 断点编号
    - 设置断点无效
        disable 断点编号
    - 设置断点生效
        enable 断点编号
    - 设置条件断点
        break 行号 if i==5
    - 运行GDB程序
        start -> 程序停在第一行   run -> 遇到断点才停
    - 继续执行, 到下一个断点停
        continue
    - 向下执行一行代码
        next
    - 变量操作
        print 变量名    ptype 变量名
    - 向下单步调试
        step  finish(跳出函数体)
    - 自动变量操作
        display 变量名(自动打印指定变量的值)    info display   undisplay 编号
    - 其他操作
        set var 变量名=变量值    until -> 跳出循环


4.  目标文件
    - 目标文件从结构上讲, 它是已经编译后的可执行文件格式, 只是还没有经过链接的过程, 其中可能有些符号或还有些地址没有被调整. 其实它本身就是按照
      可执行文件格式存储的, 只是跟真正的可执行文件在结构上稍有不同.
    - Windows: PE-COFF 文件格式   Linux: ELF 文件
    - 可重定位文件(Relocatable File): 这类文件包含了代码和数据, 可以被用来链接成可执行文件或共享目标文件, 静态链接库也可以归为这一类。
    - 可执行文件(Executable File): 这类文件包含了可以直接执行的程序, 它的代表就是ELF可执行文件, 它们一般没有扩展名
    - 共享目标文件(Shared Object File): 这种文件包含了代码和数据, 可以在两种情况使用. 一种是链接器可以使用这种文件跟其他的可重定位文件和共享目标
      文件链接, 产生新的目标文件. 第二种是动态链接器可以将几个这种共享目标文件与可执行文件结合, 作为进程映像的一部分来运行.
    - 核心转储文件: 当进程意外终止时, 系统可以将该进程的地址空间的内容及终止时的一些其他信息转储到核心转储文件



5.  目标文件的结构
    - 一般C语言的编译后执行语句都编译成机器代码, 保存在.text段; 已初始化的全局变量和局部静态变量都保存在.data段;
        未初始化的全局变量和局部静态变量一般放在一个叫.bss的段.
    - 总体来说, 程序源代码被编译以后主要分成两种段: 程序指令和程序数据. 代码段属于程序指令, 数据段和.bss段属于程序数据.
        - 一方面程序被装载后, 数据和指令分别被映射到两个虚存区域. 由于数据区域对于进程来说是可读写的, 而指令区域对于进程来说是只读的, 所以
        这两个虚存区域的权限可以被设置成可读写和只读. 这样可以防止程序的指令被有意或无意地改写.
        - 现代CPU的缓存一般都被设计成数据缓存和指令缓存分离, 所以程序的指令和数据被分开存放对CPU的缓存命中率提高有好处.
        - 当系统中运行着多个该程序的副本时, 它们的指令都是一样的, 所以内存中只需要保存一份该程序的指令部分.
