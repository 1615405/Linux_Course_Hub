1.  系统中所有的信息, 包括磁盘文件, 内存中的程序, 内存中存放的用户数据以及网络上传送的数据, 都是由一串比特表示的. 区分不同数据对象的唯一方法是我们读到
    这些数据的上下文.

2.  GNU环境包括EMACS编辑器, GCC编译器, GDB调试器, 汇编器, 链接器, 处理二进制文件的工具以及其他一些部件.

3.  Shell 是一个命令行解释器, 它输出一个提示符, 等待输入一个命令行, 然后执行这个命令. 如果该命令行的第一个单词不是一个内置的 shell 命令, 那么 shell
    就会假设这是一个可执行文件的名字, 它将加载并运行这个文件.

4.  主存是一个临时存储设备, 在处理器执行程序时, 用来存放程序和程序处理的数据. 从物理上来说, 主存是由一组动态随机存取存储器芯片组成的. 从逻辑上来说,
    存储器是一个线性的字节数组, 每个字节都有唯一的地址(数组索引), 这些地址是从零开始的.

5.  中央处理单元, 简称处理器, 是解释(或执行)存储在主存中指令的引擎. 处理器的核心是一个大小为一个字的存储设备(或寄存器), 称为程序计数器(PC).
    在任何时刻, PC都指向主存中的某条机器语言指令(即含有该条指令的地址).

6.  利用直接存储器存取(DMA)技术, 数据可以不通过处理器而直接从磁盘到达主存.

7.  L1和L2高速缓存是用一种叫做静态随机访问存储器(SRAM)的硬件技术实现的. 比较新的, 处理能力更强大的系统甚至有三级高级缓存. L1, L2和L3.
    系统可以获得一个很大的存储器, 同时访问速度也很快, 原因是利用了高速缓存的局部性, 即程序具有访问局部区域里的数据和代码的趋势. 存储器
    层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存.

8.  所有应用程序对硬件的操作尝试都必须通过操作系统. 操作系统有两个基本功能:
        - 防止硬件被失控的应用程序滥用
        - 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备
    操作系统通过几个基本的抽象概念(进程, 虚拟内存和文件)来实现这两个功能. 文件是对I/O设备的抽象表示, 虚拟内存是对主存和磁盘I/O设备的抽象表示,
    进程则是对处理器, 主存和I/O设备的抽象表示.

9.  进程是操作系统对一个正在运行的程序的一种抽象. 在一个系统上可以同时运行多个进程, 而每个进程都好像在独占地使用硬件. 而并发运行, 则是说一个进程
    的指令和另一个进程的指令是交错执行的. 无论是在单核还是多核系统中, 一个CPU看上去都像是在并发地执行多个进程, 这是通过处理器在进程间切换实现的.
    操作系统实现这种交错执行的机制称为上下文切换.
        - 操作系统保持跟踪进程运行所需的所有状态信息. 这种状态, 也就是上下文, 包括许多信息, 比如PC和寄存器文件的当前值, 以及主存的内容. 在任何一个
          时刻, 单处理器系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时, 就会进行上下文切换. 即保存当前进程的
          上下文, 恢复新进程的上下文, 然后将控制权传递给新进程. 新进程就会从它上次停止的地方开始.
        - 从一个进程到另一个进程的转换是由操作系统内核管理的. 内核是操作系统代码常驻主存的部分. 当应用程序需要操作系统的某些操作时, 比如读写文件,
          它就执行一条特殊的系统调用指令, 将控制权传递给内核. 然后内核执行被请求的操作并返回应用程序.

10.  虚拟内存是一个抽象概念, 它为每个进程提供了一个假象, 即每个进程都在独占地使用主存. 每个进程看到的内存都是一致的, 称为虚拟地址空间.
     在Linux中, 地址空间最上面的区域是保留给操作系统中的代码和数据的, 这对所有进程来说都是一样的. 地址空间的底部区域存放用户进程定义的代码和数据.
         - 程序代码和数据: 对所有的进程来说, 代码是从同一固定地址开始, 紧接着的是和C全局变量相对应的数据位置.
         - 堆: 代码和数据区后紧随着的是运行时堆. 代码和数据区在进程一开始运行时就被指定了大小, 与此不同, 当调用像malloc和free这样的C标准库函数时,
               堆可以在运行时动态地扩展和收缩.
         - 共享库: 大约在地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域.
         - 栈: 位于用户虚拟地址空间顶部的是用户栈, 编译器用它来实现函数调用. 和堆一样, 用户栈在程序执行期间可以动态地扩展和收缩, 特别地, 每次我们
               调用一个函数时, 栈就会增长; 从一个函数返回时, 栈就会收缩.
         - 内核虚拟内存: 地址空间顶部的区域是为内核保留的. 不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数.
    
